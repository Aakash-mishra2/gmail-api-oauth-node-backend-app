const express = require('express');
const router = express.Router();
const { google } = require('googleapis');
require('dotenv').config;
const redirectURL = "http://localhost:5000/api"
const oAuth2Client = new google.auth.OAuth2(
    process.env.CLIENT_ID,
    process.env.CLIENT_SECRET,
    redirectURL
);
oAuth2Client.setCredentials({ refresh_token: process.env.REFRESH_TOKEN });

let ticket;

router.get('/', async function (req, res, next) {
    res.header('Access-Control-Allow-Origin', 'http://localhost:8000');
    const code = req.query.code;
    try {

        ticket = await oAuth2Client.verifyIdToken({ idToken: code, audience: process.env.CLIENT_ID });

        // details of currently logged in User to frontEnd for display.
        res.status(200).json({
            name: ticket.payload.name,
            email: ticket.payload.email
        });

        seeUnreadEmailsAndReply();

        //setting interval and calling logic function in every interval
        setInterval(seeUnreadEmailsAndReply, getRandomInterval(45, 120) * 1000);
    }
    catch (err) {
        console.log('Error logging in with OAuth user', err);
        return req.sendStatus(401);
    }

});

// make sure one reply is sent and only once to a sender. Using Set data structure will not allow duplicates.
let repliedUsers = new Set();

const seeUnreadEmailsAndReply = async () => {
    try {
        const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });
        //get list of all unread messages
        const response = await gmail.users.messages.list({
            userId: ticket.payload.email,
            q: 'is:unread'
        });
        const messages = response.data.messages;
        if (messages && messages.length > 0) {
            for (let i = 0; i < messages.length; i++) {
                const conversation = messages[i];
                const thisMail = await gmail.users.messages.get({
                    userId: ticket.payload.email,
                    id: conversation.id
                });
                const allHeaders = thisMail.data.payload.headers;
                const sender = allHeaders.find((h) => h.name === 'From').value;
                const subject = allHeaders.find((h) => h.name === 'Subject').value;

                //reciever will be logged in User only , can replace with ticket.payload.email;
                const reciever = allHeaders.find((h) => h.name === 'To').value;

                //console.log('Email from : ', sender);
                //console.log('Email To', reciever);
                //console.log('Subject of Email', subject);

                //check if this sender has already been replied to in previous iterations of loop, skip if yes
                if (repliedUsers.has(sender)) {
                    console.log('not sent');
                    continue;
                }
                //get all messages in this conversation 
                const thread = await gmail.users.threads.get({
                    userId: ticket.payload.email,
                    id: conversation.threadId
                })

                //thread with no prior replies will have only one message object from sender
                const replies = thread.data.messages.slice(1);

                if (replies.length === 0) {
                    // this conversation qualifies as first time email thread sent by other to logged in users mailbox
                    //create customized reply from createNewReply() below and send 
                    await gmail.users.messages.send({
                        userId: ticket.payload.email,
                        requestBody: {
                            raw: await createNewReply(reciever, sender, subject),
                            threadId: conversation.threadId,
                        },
                    });

                    //after sending reply tag email with new label from createLabel() function
                    const labelName = 'Me_On_Vacation';
                    await gmail.users.messages.modify({
                        userId: ticket.payload.email,
                        id: conversation.id,
                        requestBody: {
                            addLabelIds: [await createLabel(labelName)]
                        },
                    });
                    console.log('Reply sent to ', sender);
                    repliedUsers.add(sender);
                }
            }
        }
    }
    catch (err) {
        console.log(err);
    }
}

//this function converts string to base64EncodedEmail format
const createNewReply = async (from, to, subject) => {
    const emailContent = `From: ${from}\nTo: ${to}\nSubject: ${subject}\n\n This Reply is generated by Email Manager App :: 
    ${ticket.payload.name} is on a vacation right now and will get back to you soon. `;
    const base64EncodedEmail = Buffer.from(emailContent)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");

    console.log('this reply ok');
    return base64EncodedEmail;
}

const createLabel = async (labelName) => {
    //console.log('making label');
    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });
    const res = await gmail.users.labels.list({ userId: ticket.payload.email });
    const labels = res.data.labels;

    const existingLabel = labels.find((x) => x.name === labelName);
    if (existingLabel) {
        //label created already no need to create again.
        return existingLabel.id;
    }
    const newLabel = await gmail.users.labels.create({
        userId: ticket.payload.email,
        requestBody: {
            name: labelName,
            labelListVisibility: 'labelShow',
            messageListVisibility: 'show',
        },
    });
    return newLabel.data.id;
}

function getRandomInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

module.exports = router;